from collections import Counter, deque
from copy import copy

import pytest
import enaml
import numpy as np

with enaml.imports():
    from psi.controller.calibration.api import FlatCalibration
    from psi.controller.api import (extract_epochs, FIFOSignalQueue,
                                    InterleavedFIFOSignalQueue)
    from psi.token.primitives import Cos2EnvelopeFactory, ToneFactory

fs = 100e3
isi = np.round(1/76.0, 5)


@pytest.fixture
def tone1():
    # fs, level, frequency, phase, polarity, calibration
    calibration = FlatCalibration.as_attenuation()
    return ToneFactory(fs, 0, 5, 0, 1, calibration)


@pytest.fixture
def tone2():
    calibration = FlatCalibration.as_attenuation()
    return ToneFactory(fs, 0, 10, 0, 1, calibration)


@pytest.fixture
def queue(tone1, tone2):
    # Note that filter delay doesn't actually affect the samples generated by
    # the queue. Instead, it adjusts the start time of the tone burst that's
    # reported.
    queue = FIFOSignalQueue(fs)
    queue.append(copy(tone1), 1)
    queue.append(copy(tone2), 1)
    return queue


def make_tone(frequency=250, duration=5e-3):
    calibration = FlatCalibration.as_attenuation()
    tone = ToneFactory(fs, 0, frequency, 0, 1, calibration)
    envelope = Cos2EnvelopeFactory(fs, 0, 0.5e-3, duration, tone)
    return envelope


@pytest.fixture()
def tone_pip():
    return make_tone()


def test_long_tone_queue():
    conn = deque()
    queue = InterleavedFIFOSignalQueue(fs)
    queue.connect(conn.append)

    t1 = make_tone(1e3, 1)
    t2 = make_tone(5e3, 1)
    queue.append(t1, 5)
    queue.append(t2, 5)
    waveforms = []
    for i in range(16):
        w = queue.pop_buffer(25000)
        waveforms.append(w)
    waveforms = np.concatenate(waveforms, axis=-1)
    waveforms.shape = 4, -1
    assert waveforms.shape == (4, fs)
    assert np.all(waveforms[0] == waveforms[2])
    assert np.all(waveforms[1] == waveforms[3])
    assert np.any(waveforms[0] != waveforms[1])


def make_queue(ordering, frequencies, trials):
    if ordering == 'FIFO':
        queue = FIFOSignalQueue(fs)
    elif ordering == 'interleaved':
        queue = InterleavedFIFOSignalQueue(fs)
    else:
        raise ValueError(f'Unrecognized queue ordering {ordering}')

    conn = deque()
    queue.connect(conn.append, 'added')
    removed_conn = deque()
    queue.connect(removed_conn.append, 'removed')

    keys = []
    tones = []
    duration = 5e-3
    for frequency in frequencies:
        t = make_tone(frequency=frequency, duration=duration)
        k = queue.append(t, trials, isi-duration)
        keys.append(k)
        tones.append(t)

    return queue, conn, removed_conn, keys, tones


def test_fifo_queue_pause_with_requeue():

    # Helper function to track number of remaining keys
    def _adjust_remaining(k1, k2, n):
        nk1 = min(k1, n)
        nk2 = min(n-nk1, k2)
        print(k1, k2, n, nk1, nk2)
        return k1-nk1, k2-nk2

    queue, conn, rem_conn, (k1, k2), (t1, t2) = \
        make_queue('FIFO', [1e3, 5e3], 100)
    extractor_conn = deque()
    extractor_rem_conn = deque()
    queue.connect(extractor_conn.append, 'added')
    queue.connect(extractor_rem_conn.append, 'removed')

    # Generate the waveform template
    n_t1 = t1.get_remaining_samples()
    n_t2 = t2.get_remaining_samples()
    t1_waveform = t1.next(n_t1)
    t2_waveform = t2.next(n_t2)

    waveforms = []
    extractor = extract_epochs(fs=fs,
                               queue=extractor_conn,
                               removed_queue=extractor_rem_conn,
                               poststim_time=0,
                               buffer_size=0,
                               epoch_size=15e-3,
                               target=waveforms.extend)

    # Track number of trials remaining
    k1_left, k2_left = 100, 100

    ###########################################################################
    # First, queue up 2 seconds worth of trials
    ###########################################################################
    waveform = queue.pop_buffer(int(2*fs))
    n_queued = np.floor(2/isi) + 1
    t1_lb = 0
    t2_lb = int(fs*isi*100)
    assert np.all(waveform[t1_lb:t1_lb+n_t1] == t1_waveform)
    assert np.all(waveform[t2_lb:t2_lb+n_t2] == t2_waveform)

    assert len(conn) == np.ceil(2 / isi)
    assert len(rem_conn) == 0
    keys = [i['key'] for i in conn]
    assert set(keys) == {k1, k2}
    assert set(keys[:100]) == {k1}
    assert set(keys[100:]) == {k2}

    k1_left, k2_left = _adjust_remaining(k1_left, k2_left, n_queued)
    assert queue.remaining_trials(k1) == k1_left
    assert queue.remaining_trials(k2) == k2_left
    conn.clear()

    ###########################################################################
    # Now, pause
    ###########################################################################
    # Pausing should remove all epochs queued up after 0.5s. After sending
    # the first waveform to the extractor, we generate a new waveform to
    # verify that no additional trials are queued and send that to the
    # extractor.
    queue.pause(0.5)
    extractor.send(waveform[:int(0.5*fs)])

    # We need to add 1 to account for the very first trial.
    n_queued = int(np.floor(2/isi)) + 1
    n_kept = int(np.floor(0.5/isi)) + 1

    # Now, fix the counters
    k1_left, k2_left = _adjust_remaining(100, 100, n_kept)

    # This is the total number that were removed when we paused.
    n_removed = n_queued - n_kept

    # Subtract 1 because we haven't fully captured the last trial that
    # remains in the queue because the epoch_size was chosen such that the
    # end of the epoch to be extracted is after 0.5s.
    n_captured = n_kept - 1
    assert len(waveforms) == n_captured

    # Doing this will capture the final epoch.
    waveform = queue.pop_buffer(int(fs))
    assert np.all(waveform == 0)
    extractor.send(waveform)
    assert len(waveforms) == (n_captured + 1)

    # Verify removal event is properly notifying the timestamp
    rem_t0 = np.array([i['t0'] for i in rem_conn])
    assert np.all(rem_t0 >= 0.5)
    assert (rem_t0[0] % isi) == pytest.approx(0)

    assert queue.remaining_trials(k1) == k1_left
    assert queue.remaining_trials(k2) == k2_left
    assert len(conn) == 0
    assert len(rem_conn) == n_removed

    rem_count = Counter(i['key'] for i in rem_conn)
    assert rem_count[k1] == 100-n_kept
    assert rem_count[k2] == n_queued-100
    conn.clear()
    rem_conn.clear()

    queue.resume(1.5)
    waveform = queue.pop_buffer(int(fs))
    n_queued = np.floor(1/isi) + 1
    k1_left, k2_left = _adjust_remaining(k1_left, k2_left, n_queued)

    extractor.send(waveform)
    assert len(conn) == np.floor(1/isi) + 1
    assert queue.remaining_trials(k1) == k1_left
    assert queue.remaining_trials(k2) == k2_left
    assert len(conn) == np.floor(1/isi) + 1
    keys += [i['key'] for i in conn]
    conn.clear()

    waveform = queue.pop_buffer(int(5*fs))
    n_queued = np.floor(1/isi) + 1
    k1_left, k2_left = _adjust_remaining(k1_left, k2_left, n_queued)

    extractor.send(waveform)
    assert queue.remaining_trials(k1) == 0
    assert queue.remaining_trials(k2) == 0
    keys += [i['key'] for i in conn]

    # We requeued 1.5 second worth of trials so need to factor this because
    # keys (from conn) did not remove the removed keys.
    assert len(keys) == (200 + n_removed)

    # However, the extractor is smart enough to handle cancel appropriately
    # and should only have the 200 we originally intended.
    assert len(waveforms) == 200


def test_queue_isi_with_pause(tone_pip):
    '''
    Verifies that queue generates samples at the expected ISI and also verifies
    pause functionality works as expected.
    '''
    iti = 1/100.0

    conn = deque()
    queue = FIFOSignalQueue(fs)
    queue.connect(conn.append)

    samples = int(fs)
    duration = samples/fs
    isi = tone_pip.duration + iti
    expected_n = int(duration / isi) + 1
    trials = 500

    queue.append(tone_pip, trials, delays=iti)

    queue.pop_buffer(samples)
    assert len(conn) == expected_n

    queue.pause()
    waveform = queue.pop_buffer(samples)
    assert np.sum(waveform**2) == 0
    assert len(conn) == np.ceil(duration*1 / isi)
    queue.resume()

    queue.pop_buffer(samples)
    assert len(conn) == np.ceil(duration*2 / isi)
    queue.pop_buffer(samples)
    assert len(conn) == np.ceil(duration*3 / isi)

    times = [u['t0'] for u in conn]
    assert times[0] == 0
    all_isi = np.diff(times)

    # We paused the playout, so this means that we have a very long delay in
    # the middle of the queue. Check for this delay, ensure that there's only
    # one ISI with this delay and then verify that all other ISIs are the
    # expected ISI given the tone pip duration.
    assert all_isi.max() == duration + isi
    m = all_isi == all_isi.max()
    assert sum(m) == 1
    np.testing.assert_almost_equal(all_isi[~m], isi)


def test_fifo_queue_pause_resume_timing():
    trials = 20
    samples = int(fs)
    queue, conn, _, _, _ = make_queue('FIFO', (1e3, 5e3), trials)
    queue.pop_buffer(samples)
    conn.clear()
    queue.pause(0.1025)
    queue.pop_buffer(samples)
    queue.resume(0.6725)
    queue.pop_buffer(samples)
    t0 = [i['t0'] for i in conn]
    assert t0[0] == 0.6725


def test_fifo_queue_ordering():
    trials = 20
    samples = int(fs)

    queue, conn, _, (k1, k2), (t1, _) = \
        make_queue('FIFO', (1e3, 5e3), trials)
    epoch_samples = int(t1.duration * fs)

    waveforms = []
    queue_empty = False
    def mark_empty():
        nonlocal queue_empty
        queue_empty = True

    extractor = extract_epochs(fs=fs,
                               queue=conn,
                               epoch_size=None,
                               poststim_time=0,
                               buffer_size=0,
                               target=waveforms.extend,
                               empty_queue_cb=mark_empty)

    waveform = queue.pop_buffer(samples)
    extractor.send(waveform)

    metadata = list(conn)
    for md in metadata[:trials]:
        assert k1 == md['key']
    for md in metadata[trials:]:
        assert k2 == md['key']

    waveforms = np.vstack([w['signal'] for w in waveforms])
    assert queue_empty
    assert waveforms.shape == (trials * 2, epoch_samples)
    for w in waveforms[:trials]:
        assert np.all(w == waveforms[0])
    for w in waveforms[trials:]:
        assert np.all(w == waveforms[trials])
    assert np.any(waveforms[0] != waveforms[trials])


def test_interleaved_fifo_queue_ordering():
    samples = int(fs)
    trials = 20

    queue, conn, _, (k1, k2), (t1, _) = \
        make_queue('interleaved', (1e3, 5e3), trials)
    epoch_samples = int(t1.duration * fs)

    waveforms = []
    queue_empty = False
    def mark_empty():
        nonlocal queue_empty
        queue_empty = True

    extractor = extract_epochs(fs=fs,
                               queue=conn,
                               epoch_size=None,
                               poststim_time=0,
                               buffer_size=0,
                               target=waveforms.extend,
                               empty_queue_cb=mark_empty)

    waveform = queue.pop_buffer(samples)
    extractor.send(waveform)

    metadata = list(conn)
    for md in metadata[::2]:
        assert k1 == md['key']
    for md in metadata[1::2]:
        assert k2 == md['key']

    waveforms = np.vstack([w['signal'] for w in waveforms])
    assert queue_empty
    assert waveforms.shape == (trials * 2, epoch_samples)
    for w in waveforms[::2]:
        assert np.all(w == waveforms[0])
    for w in waveforms[1::2]:
        assert np.all(w == waveforms[1])
    assert np.any(waveforms[0] != waveforms[1])


def test_queue_continuous_tone(queue, tone1, tone2):
    '''
    Test ability to work with continuous tones and move to the next one
    manually (e.g., as in the case of DPOAEs).
    '''
    conn = deque()
    queue.connect(conn.append)

    assert queue.get_max_duration() is np.inf

    s1 = queue.pop_buffer(fs)
    gs1 = tone1.next(fs)
    assert np.allclose(s1, gs1)

    s1 = queue.pop_buffer(fs)
    gs1 = tone1.next(fs)
    assert np.allclose(s1, gs1)

    queue.next_trial()

    s2 = queue.pop_buffer(fs)
    gs2 = tone2.next(fs)
    assert np.allclose(s2, gs2)

    s2 = queue.pop_buffer(fs)
    gs2 = tone2.next(fs)
    assert np.allclose(s2, gs2)

    assert len(conn) == 2
    # Set resolution to a fraction of a sample
    assert conn.popleft()['t0'] == pytest.approx(0, abs=0.1/fs)
    assert conn.popleft()['t0'] == pytest.approx(2, abs=0.1/fs)
